#!/usr/bin/python
#
# anaconda: The Red Hat Linux Installation program
#
# Copyright (C) 1999-2014
# Red Hat, Inc.  All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author(s): Brent Fox <bfox@redhat.com>
#            Mike Fulbright <msf@redhat.com>
#            Jakub Jelinek <jakub@redhat.com>
#            Jeremy Katz <katzj@redhat.com>
#            Chris Lumens <clumens@redhat.com>
#            Paul Nasrat <pnasrat@redhat.com>
#            Erik Troan <ewt@rpath.com>
#            Matt Wilson <msw@rpath.com>
#

# This toplevel file is a little messy at the moment...

coverage = None

proc_cmdline = open("/proc/cmdline", "r").read()
proc_cmdline = proc_cmdline.split()
if ("debug=1" in proc_cmdline) or ("debug" in proc_cmdline):
    import coverage
    cov = coverage.coverage(data_file="/mnt/sysimage/root/anaconda.coverage",
                            branch=True,
                            source=["/usr/sbin/anaconda", "pyanaconda"]
                            )
    cov.start()


import atexit, sys, os, time, subprocess
# keep up with process ID of the window manager if we start it
wm_pid = None

def exitHandler(rebootData, storage, exitCode=None):
    # stop and save coverage here b/c later the file system may be unavailable
    if coverage is not None:
        cov.stop()
        if os.path.isdir('/mnt/sysimage/root'):
            cov.save()

    if exitCode:
        anaconda.intf.shutdown()

    if "nokill" in flags.cmdline:
        iutil.vtActivate(1)
        print "anaconda halting due to nokill flag."
        print "The system will be rebooted when you press Ctrl-Alt-Delete."
        while True:
            time.sleep(10000)

    if image_count or flags.dirInstall:
        anaconda.storage.umountFilesystems(swapoff=False)
        devicetree = anaconda.storage.devicetree
        devicetree.teardownAll()
        for imageName in devicetree.diskImages:
            dev = devicetree.getDeviceByName(imageName)
            for loop in dev.parents:
                loop.controllable = True
            dev.deactivate(recursive=True)

    if not flags.imageInstall and not flags.livecdInstall \
       and not flags.dirInstall:
        from pykickstart.constants import KS_SHUTDOWN, KS_WAIT
        from pyanaconda.iutil import dracut_eject, get_mount_paths

        if flags.eject or rebootData.eject:
            for cdrom in storage.devicetree.getDevicesByType("cdrom"):
                if get_mount_paths(cdrom.path):
                    dracut_eject(cdrom.path)

        if rebootData.action == KS_SHUTDOWN:
            subprocess.Popen(["systemctl", "--no-wall", "poweroff"])
        elif rebootData.action == KS_WAIT:
            subprocess.Popen(["systemctl", "--no-wall", "halt"])
        else: # reboot action is KS_REBOOT or None
            subprocess.Popen(["systemctl", "--no-wall", "reboot"])

    # NOTE: anaconda may terminate early (via XIOErrorHandler) when you kill
    # the X server, so this should happen last.
    if flags.usevnc:
        vnc.shutdownServer()

def startMetacityWM():
    childpid = os.fork()
    if not childpid:
        # after this point the method should never return (or throw an exception
        # outside)
        try:
            iutil.execWithRedirect('metacity', ["--display", ":1", "--sm-disable"])
        except BaseException as e:
            # catch all possible exceptions
            log.error("Problems running the window manager: %s", str(e))
            os._exit(1)

        log.info("The window manager has terminated.")
        os._exit(0)
    return childpid

def startAuditDaemon():
    childpid = os.fork()
    if not childpid:
        cmd = '/sbin/auditd'
        try:
            os.execl(cmd, cmd)
        except OSError as e:
            log.error("Error running the audit daemon: %s", str(e))
        os._exit(0)
    # auditd will turn into a daemon so catch the immediate child pid now:
    os.waitpid(childpid, 0)

# function to handle X startup special issues for anaconda
def doStartupX11Actions():
    """Start window manager"""

    global wm_pid # pid of the anaconda fork where the window manager is running

    # now start up the window manager
    wm_pid = startMetacityWM()
    log.info("Starting window manager, pid %s.", wm_pid)

def set_x_resolution(runres):
    # cant do this if no window manager is running because otherwise when we
    # open and close an X connection in the xutils calls the X server will exit
    # since this is the first X connection (if no window manager is running)
    if runres and opts.display_mode == 'g' and not flags.usevnc and wm_pid :
        try:
            log.info("Setting the screen resolution to: %s.", runres)
            iutil.execWithRedirect("xrandr",
                                   ["-d", ":1", "-s", runres])
        except RuntimeError:
            log.error("The X resolution not set")
            iutil.execWithRedirect("xrandr",
                                   ["-d", ":1", "-q"])

def setupPythonUpdates():
    from distutils.sysconfig import get_python_lib
    import gi.overrides

    # Temporary hack for F18 alpha to symlink updates and product directories
    # into tmpfs.  To be removed after beta in order to directly use content
    # from /run/install/ -- JLK
    for dirname in ("updates", "product"):
        if os.path.exists("/run/install/%s" % dirname):
            if os.path.islink("/tmp/%s" % dirname):
                # Assume updates have already been setup
                return
            os.symlink("/run/install/%s" % dirname,
                       "/tmp/%s" % dirname)

    if not os.path.exists("/tmp/updates"):
        return

    for pkg in os.listdir("/tmp/updates"):
        d = "/tmp/updates/%s" % pkg

        if not os.path.isdir(d):
            continue

        # See if the package exists in /usr/lib{64,}/python/?.?/site-packages.
        # If it does, we can set it up as an update.  If not, the pkg is
        # likely a completely new directory and should not be looked at.
        dest = "%s/%s" % (get_python_lib(), pkg)
        if not os.access(dest, os.R_OK):
            dest = "%s/%s" % (get_python_lib(1), pkg)
            if not os.access(dest, os.R_OK):
                continue
        # Symlink over everything that's in the python libdir but not in
        # the updates directory.
        symlink_updates(dest, d)

    gi.overrides.__path__.insert(0, "/run/install/updates")

    import glob
    import shutil
    for rule in glob.glob("/tmp/updates/*.rules"):
        target = "/etc/udev/rules.d/" + rule.split('/')[-1]
        shutil.copyfile(rule, target)

def symlink_updates(dest_dir, update_dir):
    contents = os.listdir(update_dir)

    for f in os.listdir(dest_dir):
        dest_path = os.path.join(dest_dir, f)
        update_path = os.path.join(update_dir, f)
        if f in contents:
            # recurse into directories, there might be files missing in updates
            if os.path.isdir(dest_path) and os.path.isdir(update_path):
                symlink_updates(dest_path, update_path)
        else:
            if f.endswith(".pyc") or f.endswith(".pyo"):
                continue
            os.symlink(dest_path, update_path)

def getAnacondaVersionString():
    # we are importing the startup module directly so that it can be replaced
    # by updates image, if it was replaced before the updates image can be
    # loaded, it could not be easily replaced
    from pyanaconda import startup_utils
    return startup_utils.get_anaconda_version_string()


def parseArguments(argv=None, boot_cmdline=None):
    from pyanaconda.anaconda_argparse import AnacondaArgumentParser
    from pyanaconda.anaconda_argparse import HelpTextParser

    datadir = os.environ.get("ANACONDA_DATADIR", "/usr/share/anaconda")

    # NOTE: for each long option (like '--repo'), AnacondaOptionParser
    # checks the boot arguments for bootarg_prefix+option ('inst.repo').
    # If require_prefix is False, it also accepts the option without the
    # bootarg_prefix ('repo').
    # See anaconda_optparse.py and BootArgs (in flags.py) for details.
    ap = AnacondaArgumentParser(bootarg_prefix="inst.", require_prefix=False)
    help_parser = HelpTextParser(os.path.join(datadir, "anaconda_options.txt"))

    # NOTE: store_false options will *not* get negated when the user does
    # "option=0" on the boot commandline (store_true options do, though).
    # Basically, don't use store_false unless the option starts with "no".

    # YET ANOTHER NOTE: If you change anything here:
    # a) document its usage in docs/boot-options.txt
    # b) be prepared to maintain it for a very long time
    # If this seems like too much trouble, *don't add a new option*!

    # Version
    ap.add_argument('--version', action='version', version="%(prog)s " + getAnacondaVersionString())

    # Interface
    ap.add_argument("-C", "--cmdline", dest="display_mode", action="store_const", const="c",
                    default="g", help=help_parser.help_text("cmdline"))
    ap.add_argument("-G", "--graphical", dest="display_mode", action="store_const", const="g",
                    help=help_parser.help_text("graphical"))
    ap.add_argument("-T", "--text", dest="display_mode", action="store_const", const="t",
                    help=help_parser.help_text("text"))

    # Network
    ap.add_argument("--proxy", metavar='PROXY_URL', help=help_parser.help_text("proxy"))

    # Method of operation
    ap.add_argument("-d", "--debug", dest="debug", action="store_true",
                    default=False, help=help_parser.help_text("debug"))
    ap.add_argument("--ks", dest="ksfile", action="store_const",
                    metavar="KICKSTART_URL", const="/run/install/ks.cfg",
                    help=help_parser.help_text("ks"))
    ap.add_argument("--kickstart", dest="ksfile", metavar="KICKSTART_PATH",
                    help=help_parser.help_text("kickstart"))
    ap.add_argument("--rescue", dest="rescue", action="store_true", default=False,
                    help=help_parser.help_text("rescue"))
    ap.add_argument("--armplatform", dest="armPlatform", type=str, metavar="PLATFORM_ID",
                    help=help_parser.help_text("armplatform"))
    ap.add_argument("--multilib", dest="multiLib", action="store_true", default=False,
                    help=help_parser.help_text("multilib"))

    ap.add_argument("-m", "--method", dest="method", default=None, metavar="METHOD",
                    help=help_parser.help_text("method"))
    ap.add_argument("--askmethod", dest="askmethod", action="store_true", default=False,
                    help=help_parser.help_text("askmethod"))
    ap.add_argument("--repo", dest="method", default=None, metavar="REPO_URL",
                    help=help_parser.help_text("repo"))
    ap.add_argument("--stage2", dest="stage2", default=None, metavar="STAGE2_URL",
                    help=help_parser.help_text("stage2"))
    ap.add_argument("--noverifyssl", action="store_true", default=False,
                    help=help_parser.help_text("noverifyssl"))
    ap.add_argument("--liveinst", action="store_true", default=False,
                    help=help_parser.help_text("liveinst"))

    # Display
    ap.add_argument("--resolution", dest="runres", default=None, metavar="WIDTHxHEIGHT",
                    help=help_parser.help_text("resolution"))
    ap.add_argument("--usefbx", dest="xdriver", action="store_const", const="fbdev",
                    help=help_parser.help_text("usefbx"))
    ap.add_argument("--vnc", action="store_true", default=False,
                    help=help_parser.help_text("vnc"))
    ap.add_argument("--vncconnect", metavar="HOST:PORT", help=help_parser.help_text("vncconnect"))
    ap.add_argument("--vncpassword", default="", metavar="PASSWORD",
                    help=help_parser.help_text("vncpassword"))
    ap.add_argument("--xdriver", dest="xdriver", action="store", type=str,
                    default=None, metavar="DRIVER", help=help_parser.help_text("xdriver"))

    # Language
    ap.add_argument("--keymap", metavar="KEYMAP", help=help_parser.help_text("keymap"))
    ap.add_argument("--lang", metavar="LANG", help=help_parser.help_text("lang"))

    # Obvious
    ap.add_argument("--loglevel", metavar="LEVEL", help=help_parser.help_text("loglevel"))
    ap.add_argument("--syslog", metavar="HOST[:PORT]", help=help_parser.help_text("syslog"))

    from pykickstart.constants import SELINUX_DISABLED, SELINUX_ENFORCING
    from pyanaconda.constants import SELINUX_DEFAULT
    ap.add_argument("--noselinux", dest="selinux", action="store_const",
                    const=SELINUX_DISABLED, default=SELINUX_DEFAULT,
                    help=help_parser.help_text("noselinux"))
    ap.add_argument("--selinux", action="store_const",
                    const=SELINUX_ENFORCING, help=help_parser.help_text("selinux"))

    ap.add_argument("--nompath", dest="mpath", action="store_false", default=True,
                    help=help_parser.help_text("nompath"))
    ap.add_argument("--mpath", action="store_true", help=help_parser.help_text("mpath"))

    ap.add_argument("--nodmraid", dest="dmraid", action="store_false", default=True,
                    help=help_parser.help_text("nodmraid"))
    ap.add_argument("--dmraid", action="store_true", help=help_parser.help_text("dmraid"))

    ap.add_argument("--noibft", dest="ibft", action="store_false", default=True,
                    help=help_parser.help_text("noibft"))
    ap.add_argument("--ibft", action="store_true", help=help_parser.help_text("ibft"))

    # Geolocation
    ap.add_argument("--geoloc", metavar="PROVIDER_ID", help=help_parser.help_text("geoloc"))

    # Miscellaneous
    ap.add_argument("--nomount", dest="rescue_nomount", action="store_true", default=False,
                    help=help_parser.help_text("nomount"))
    ap.add_argument("--updates", dest="updateSrc", action="store", type=str,
                    metavar="UPDATES_URL", help=help_parser.help_text("updates"))
    ap.add_argument("--image", action="append", dest="images", default=[],
                    metavar="IMAGE_SPEC", help=help_parser.help_text("image"))
    ap.add_argument("--dirinstall", action="store_true", default=False,
                    help=help_parser.help_text("dirinstall"))
    ap.add_argument("--memcheck", action="store_true", default=True,
                    help=help_parser.help_text("memcheck"))
    ap.add_argument("--nomemcheck", action="store_false", dest="memcheck",
                    help=help_parser.help_text("nomemcheck"))
    ap.add_argument("--leavebootorder", action="store_true", default=False,
                    help=help_parser.help_text("leavebootorder"))
    ap.add_argument("--noeject", action="store_false", dest="eject", default=True,
                    help=help_parser.help_text("noeject"))
    ap.add_argument("--extlinux", action="store_true", default=False,
                    help=help_parser.help_text("extlinux"))
    ap.add_argument("--mpathfriendlynames", action="store_true", default=True,
                    help=help_parser.help_text("mpathfriendlynames"))

    # some defaults change based on boot_cmdline flags
    if boot_cmdline is not None:
        if "console" in boot_cmdline:
            ap.set_defaults(display_mode="t")

    namespace = ap.parse_args(argv, boot_cmdline=boot_cmdline)
    return (namespace, ap.deprecated_bootargs)

def setupPythonPath():
    # First add our updates path
    sys.path.insert(0, '/tmp/updates/')

    from pyanaconda.constants import ADDON_PATHS
    # append ADDON_PATHS dirs at the end
    sys.path.extend(ADDON_PATHS)

def setupEnvironment():
    # Silly GNOME stuff
    if os.environ.has_key('HOME') and not os.environ.has_key("XAUTHORITY"):
        os.environ['XAUTHORITY'] = os.environ['HOME'] + '/.Xauthority'
    os.environ['HOME'] = '/tmp'
    os.environ['LC_NUMERIC'] = 'C'
    os.environ["GCONF_GLOBAL_LOCKS"] = "1"

    # In theory, this gets rid of our LVM file descriptor warnings
    os.environ["LVM_SUPPRESS_FD_WARNINGS"] = "1"

    # make sure we have /sbin and /usr/sbin in our path
    os.environ["PATH"] += ":/sbin:/usr/sbin"

    # we can't let the LD_PRELOAD hang around because it will leak into
    # rpm %post and the like.  ick :/
    if os.environ.has_key("LD_PRELOAD"):
        del os.environ["LD_PRELOAD"]

def setupLoggingFromOpts(options):
    if options.loglevel and anaconda_log.logLevelMap.has_key(options.loglevel):
        level = anaconda_log.logLevelMap[options.loglevel]
        anaconda_log.logger.loglevel = level
        anaconda_log.setHandlersLevel(log, level)
        storage_log = logging.getLogger("storage")
        anaconda_log.setHandlersLevel(storage_log, level)

    if options.syslog:
        anaconda_log.logger.updateRemote(options.syslog)

def gtk_warning(title, reason):
    from gi.repository import Gtk
    dialog = Gtk.MessageDialog(type = Gtk.MessageType.ERROR,
                               buttons = Gtk.ButtonsType.CLOSE,
                               message_format=reason)
    dialog.set_title(title)
    dialog.run()
    dialog.destroy()

# pylint: disable=W0621
def check_memory(anaconda, opts, display_mode=None):
    reason_strict = _("%(product_name)s requires %(needed_ram)s MB of memory to install, but you only have "
                      "%(total_ram)s MB on this machine.\n")
    reason_graphical = _("The %(product_name)s graphical installer requires %(needed_ram)s MB of memory, but "
                         "you only have %(total_ram)s MB.")

    reboot_extra = _('\n'
                     'Press <return> to reboot your system.\n')
    livecd_title = _("Not enough RAM")
    livecd_extra =_(" Try the text mode installer by running:\n\n"
                    "'/usr/bin/liveinst -T'\n\n from a root "
                    "terminal.")
    nolivecd_extra = _(" Starting text mode.")

    if opts.rescue:
        return

    if not display_mode:
        display_mode = anaconda.displayMode

    reason = reason_strict
    total_ram = int(isys.total_memory() / 1024)
    needed_ram = int(isys.MIN_RAM / 1024)
    graphical_ram = needed_ram + int(isys.GUI_INSTALL_EXTRA_RAM / 1024)

    log.info("check_memory(): total:%s, needed:%s, graphical:%s",
             total_ram, needed_ram, graphical_ram)

    if not opts.memcheck:
        log.warning("CHECK_MEMORY DISABLED")
        return

    reason_args = {"product_name": product.productName,
                   "needed_ram": needed_ram,
                   "total_ram": total_ram}
    if needed_ram > total_ram:
        from snack import SnackScreen, ButtonChoiceWindow
        if opts.liveinst:
            # pylint: disable=W1201
            stdoutLog.warning(reason % reason_args)
            gtk_warning(livecd_title, reason % reason_args)
        else:
            reason += reboot_extra
            screen = SnackScreen()
            ButtonChoiceWindow(screen, _('Fatal Error'),
                               reason % reason_args,
                               buttons = (_("OK"),))
            screen.finish()

        iutil.ipmi_report(constants.IPMI_ABORTED)
        sys.exit(1)

    # override display mode if machine cannot nicely run X
    if display_mode not in ('t', 'c', 's') and not flags.usevnc:
        needed_ram = graphical_ram
        reason_args["needed_ram"] = graphical_ram
        reason = reason_graphical

        if needed_ram > total_ram:
            if opts.liveinst:
                reason += livecd_extra
                # pylint: disable=W1201
                stdoutLog.warning(reason % reason_args)
                title = livecd_title
                gtk_warning(title, reason % reason_args)
                iutil.ipmi_report(constants.IPMI_ABORTED)
                sys.exit(1)
            else:
                reason += nolivecd_extra
                # pylint: disable=W1201
                stdoutLog.warning(reason % reason_args)
                anaconda.displayMode = 't'
                time.sleep(2)

# pylint: disable=W0621
def setupDisplay(anaconda, opts, addon_paths=None):
    from pyanaconda.ui.tui.simpleline import App
    from pyanaconda.ui.tui.spokes.askvnc import AskVNCSpoke
    from pykickstart.constants import DISPLAY_MODE_TEXT
    from pyanaconda.nm import nm_is_connected, nm_is_connecting
    from blivet import arch
    import blivet.util

    graphical_failed = 0
    vncS = vnc.VncServer()          # The vnc Server object.
    vncS.anaconda = anaconda

    anaconda.displayMode = opts.display_mode
    anaconda.isHeadless = arch.isS390()

    if opts.vnc:
        flags.usevnc = True
        anaconda.displayMode = 'g'
        vncS.password = opts.vncpassword

        # Only consider vncconnect when vnc is a param
        if opts.vncconnect:
            cargs = string.split(opts.vncconnect, ":")
            vncS.vncconnecthost = cargs[0]
            if len(cargs) > 1 and len(cargs[1]) > 0:
                if len(cargs[1]) > 0:
                    vncS.vncconnectport = cargs[1]

    if opts.xdriver:
        anaconda.xdriver = opts.xdriver
        anaconda.writeXdriver(root="/")

    if flags.rescue_mode:
        return

    if anaconda.ksdata.vnc.enabled:
        flags.usevnc = True
        anaconda.displayMode = 'g'

        if vncS.password == "":
            vncS.password = anaconda.ksdata.vnc.password

        if vncS.vncconnecthost == "":
            vncS.vncconnecthost = anaconda.ksdata.vnc.host

        if vncS.vncconnectport == "":
            vncS.vncconnectport = anaconda.ksdata.vnc.port

    if anaconda.displayMode == "g":
        import pkgutil
        import pyanaconda.ui

        mods = (tup[1] for tup in pkgutil.iter_modules(pyanaconda.ui.__path__, "pyanaconda.ui."))
        if "pyanaconda.ui.gui" not in mods:
            stdoutLog.warning("Graphical user interface not available, falling back to text mode")
            anaconda.displayMode = "t"
            flags.usevnc = 0
            flags.vncquestion = False

    # disable VNC over text question when not enough memory is available
    if blivet.util.total_memory() < isys.MIN_GUI_RAM:
        stdoutLog.warning("Not asking for VNC because current memory (%d) < MIN_GUI_RAM (%d)", blivet.util.total_memory(), isys.MIN_GUI_RAM)
        flags.vncquestion = False

    # disable VNC question if text mode is requested and this is a ks install
    if anaconda.displayMode == 't' and flags.automatedInstall:
        stdoutLog.warning("Not asking for VNC because of an automated install")
        flags.vncquestion = False

    # disable VNC question if we were explicitly asked for text in kickstart
    if anaconda.ksdata.displaymode.displayMode == DISPLAY_MODE_TEXT:
        stdoutLog.warning("Not asking for VNC because text mode was explicitly asked for in kickstart")
        flags.vncquestion = False

    # disable VNC question if we don't have network
    if not nm_is_connecting() and not nm_is_connected():
        stdoutLog.warning("Not asking for VNC because we don't have a network")
        flags.vncquestion = False

    # disable VNC question if we don't have Xvnc
    if not os.access('/usr/bin/Xvnc', os.X_OK):
        stdoutLog.warning("Not asking for VNC because we don't have Xvnc")
        flags.vncquestion = False

    if os.environ.has_key('DISPLAY'):
        flags.preexisting_x11 = True

    # Should we try to start Xorg?
    want_x = anaconda.displayMode == 'g' and \
             not (flags.preexisting_x11 or flags.usevnc)

    # X on a headless (e.g. s390) system? Nonsense!
    if want_x and anaconda.isHeadless:
        stdoutLog.warning(_("DISPLAY variable not set. Starting text mode."))
        anaconda.displayMode = 't'
        graphical_failed = 1
        time.sleep(2)
        want_x = False

    # Is Xorg is actually available?
    if want_x and not os.access("/usr/bin/Xorg", os.X_OK):
        stdoutLog.warning(_("Graphical installation is not available. "
                            "Starting text mode."))
        time.sleep(2)
        anaconda.displayMode = 't'
        want_x = False

    if anaconda.displayMode == 't' and flags.vncquestion:
        #we prefer vnc over text mode, so ask about that
        message = _("Text mode provides a limited set of installation "
                    "options. It does not offer custom partitioning for "
                    "full control over the disk layout. Would you like "
                    "to use VNC mode instead?")

        app = App("VNC Question")
        spoke = AskVNCSpoke(app, anaconda.ksdata, message=message)
        app.schedule_screen(spoke)
        app.run()

        if anaconda.ksdata.vnc.enabled:
            anaconda.displayMode = 'g'
            flags.usevnc = True
            vncS.password = anaconda.ksdata.vnc.password
        else:
            # user has explicitly specified text mode
            flags.vncquestion = False

    log.info("Display mode = %s", anaconda.displayMode)
    check_memory(anaconda, opts)

    if want_x:
        # The following code depends on no SIGCHLD being delivered,
        # possibly only except the one from a failing X.org. Thus
        # make sure before entering this section that all the other
        # children of anaconda have terminated or were forked into
        # an orphan (which won't deliver a SIGCHLD to mess up the
        # fragile signaling below). start X with its USR1 handler
        # set to ignore.  this will make it send us SIGUSR1 if it
        # succeeds.  if it fails, catch SIGCHLD and bomb out.
        def sigchld_handler(num, frame):
            raise OSError(0, "SIGCHLD caught when trying to start the X server.")

        def sigusr1_handler(num, frame):
            log.debug("X server has signalled a successful start.")

        def preexec_fn():
            signal.signal(signal.SIGUSR1, signal.SIG_IGN)

        old_sigusr1 = signal.signal(signal.SIGUSR1, sigusr1_handler)
        old_sigchld = signal.signal(signal.SIGCHLD, sigchld_handler)
        xout = open("/dev/tty5", "w")
        try:
            subprocess.Popen(["Xorg", "-br",
                              "-logfile", "/tmp/X.log",
                              ":1", "vt6", "-s", "1440", "-ac",
                              "-nolisten", "tcp", "-dpi", "96",
                              "-noreset"],
                              close_fds=True,
                              stdout=xout, stderr=xout,
                              preexec_fn=preexec_fn)

            signal.pause()
            os.environ["DISPLAY"] = ":1"
            doStartupX11Actions()
        except (OSError, RuntimeError):
            stdoutLog.warning("X startup failed, falling back to text mode")
            anaconda.displayMode = 't'
            graphical_failed = 1
            time.sleep(2)
        finally:
            signal.signal(signal.SIGUSR1, old_sigusr1)
            signal.signal(signal.SIGCHLD, old_sigchld)

    set_x_resolution(opts.runres)

    if anaconda.displayMode == 't' and graphical_failed and \
         flags.vncquestion and not anaconda.ksdata.vnc.enabled:
        app = App("VNC Question")
        spoke = AskVNCSpoke(app, anaconda.ksdata)
        app.schedule_screen(spoke)
        app.run()

        if anaconda.ksdata.vnc.enabled:
            anaconda.displayMode = 'g'
            flags.usevnc = True
            vncS.password = anaconda.ksdata.vnc.password

    # if they want us to use VNC do that now
    if anaconda.displayMode == 'g' and flags.usevnc:
        vncS.startServer()
        doStartupX11Actions()

    # with X running we can initialize the UI interface
    anaconda.initInterface(addon_paths)

    # STACKIQ
    file = open('/proc/cmdline', 'r')
    args = file.readline().split()
    file.close()

    if 'boss' in args:
        #
        # we are a boss
        #
        if not os.path.exists('/tmp/rolls.xml') or \
                not os.path.exists('/tmp/site.attrs'):
            log.debug('STACKIQ: Starting Boss Configuration.')
            bossenv = os.environ.copy()
            bossenv['LD_LIBRARY_PATH'] = '/opt/stack/lib'
            bossenv['DISPLAY'] = ':1'
            s = subprocess.Popen('/opt/stack/bin/boss_config.py', env = bossenv)
            s.wait()	
            log.debug('STACKIQ: Boss Configuration Complete.')

        if not os.path.exists('/tmp/boss.ks.cfg.done'):
            #
            # build kickstart file for the boss
            #
            bossenv = os.environ.copy()
            if bossenv.has_key('LD_LIBRARY_PATH'):
                bossenv['LD_LIBRARY_PATH'] = \
                    '%s:/opt/stack/lib:/tmp/updates/lib64' \
                     % bossenv['LD_LIBRARY_PATH']
            else:
                bossenv['LD_LIBRARY_PATH'] = \
                    '/opt/stack/lib:/tmp/updates/lib64'

            log.debug('STACKIQ: Building Boss Kickstart File.')
            file = open('boss_ks_file.debug', 'w')
            s = subprocess.Popen('/opt/stack/bin/boss_ks_file.py',
                env = bossenv,
                stdout = file, stderr = subprocess.STDOUT)
            s.wait()	
            file.close()
   
            # 
            # RHEL 7.x wants the kickstart file in /run/install
            # 
            import shutil
            shutil.copyfile('/tmp/ks.cfg', '/run/install/ks.cfg')

            file = open('/tmp/boss.ks.cfg.done', 'w')
            file.close()
            log.debug('STACKIQ: Building Boss Kickstart File Complete.')

            #
            # we need to restart anaconda in order to re-read the kickstart file
            # 
            # need to call os._exit() because that will kill this process and
            # call all the exeception handlers (that sys.exit() would do).
            #
            os._exit(os.EX_OK)
    # STACKIQ

    anaconda.instClass.configure(anaconda)

def prompt_for_ssh():
    # Do some work here to get the ip addr / hostname to pass
    # to the user.
    import socket

    ip = network.get_default_device_ip() or network.getFirstRealIP()

    if not ip:
        stdoutLog.error("No IP addresses found, cannot continue installation.")
        iutil.ipmi_report(constants.IPMI_ABORTED)
        sys.exit(1)

    ipstr = ip

    try:
        hinfo = socket.gethostbyaddr(ipstr)
    except socket.herror as e:
        stdoutLog.debug("Exception caught trying to get host name of %s: %s",
                        ipstr, e)
        name = network.getHostname()
    else:
        if len(hinfo) == 3:
            name = hinfo[0]

    if ip.find(':') != -1:
        ipstr = "[%s]" % (ip,)

    if (name is not None) and (not name.startswith('localhost')) and (ipstr is not None):
        connxinfo = "%s (%s)" % (socket.getfqdn(name=name), ipstr,)
    elif ipstr is not None:
        connxinfo = "%s" % (ipstr,)
    else:
        connxinfo = None

    if connxinfo:
        stdoutLog.info(_("Please ssh install@%s to begin the install."), connxinfo)
    else:
        stdoutLog.info(_("Please ssh install@<host> to continue installation."))

def cleanPStore():
    """remove files stored in nonvolatile ram created by the pstore subsystem"""

    # files in pstore are linux (not distribution) specific, but we want to
    # make sure the entirity of them are removed so as to ensure that there
    # is sufficient free space on the flash part.  On some machines this will
    # take effect immediately, which is the best case.  Unfortunately on some,
    # an intervening reboot is needed."""
    from pyanaconda.iutil import dir_tree_map
    dir_tree_map("/sys/fs/pstore", os.unlink, files=True, dirs=False)

if __name__ == "__main__":
    # check if the CLI help is requested and return it at once,
    # without importing random stuff and spamming stdout
    if ("--help" in sys.argv) or ("-h" in sys.argv) or ("--version" in sys.argv):
        # we skip the full logging initialisation, but we need to do at least
        # this much (redirect any log messages to stdout) to get rid of the
        # harmless but annoying "no handlers found" message on stdout
        import logging
        log = logging.getLogger("anaconda")
        log.addHandler(logging.StreamHandler(stream=sys.stdout))
        parseArguments()

    print "Starting installer, one moment..."

    # Allow a file to be loaded as early as possible
    try:
        # pylint: disable=F0401,W0611
        import updates_disk_hook
    except ImportError:
        pass

    # this handles setting up updates for pypackages to minimize the set needed
    setupPythonUpdates()
    setupPythonPath()

    # init threading before Gtk can do anything and before we start using threads
    # initThreading initializes the threadMgr instance, import it afterwards
    from pyanaconda.threads import initThreading, AnacondaThread
    initThreading()
    from pyanaconda.threads import threadMgr

    import gettext
    _ = lambda x: gettext.ldgettext("anaconda", x)

    from pyanaconda import constants
    from pyanaconda import addons
    from pyanaconda import geoloc

    # do this early so we can set flags before initializing logging
    from pyanaconda.flags import flags, can_touch_runtime_system
    (opts, depr) = parseArguments(boot_cmdline=flags.cmdline)

    # Set up logging as early as possible.
    import logging
    from pyanaconda import anaconda_log
    anaconda_log.init()
    anaconda_log.logger.setupVirtio()

    from pyanaconda import network
    network.setup_ifcfg_log()

    log = logging.getLogger("anaconda")
    stdoutLog = logging.getLogger("anaconda.stdout")

    if os.geteuid() != 0:
        stdoutLog.error("anaconda must be run as root.")
        sys.exit(0)

    if opts.images and opts.dirinstall:
        stdoutLog.error("--images and --dirinstall cannot be used at the same time")
        sys.exit(0)
    elif opts.images:
        flags.imageInstall = True
    elif opts.dirinstall:
        flags.dirInstall = True

    # see if we're on s390x and if we've got an ssh connection
    uname = os.uname()
    if uname[4] == 's390x':
        if 'TMUX' not in os.environ and 'ks' not in flags.cmdline and not flags.imageInstall:
            prompt_for_ssh()
            sys.exit(0)

    log.info("%s %s", sys.argv[0], getAnacondaVersionString())

    # TODO: uncomment this when we're sure that we're doing the right thing
    # with flags.cmdline *everywhere* it appears...
    #for arg in depr:
    #    stdoutLog.warn("Boot argument '%s' is deprecated. "
    #                   "In the future, use 'inst.%s'.", arg, arg)

    # pull this in to get product name and versioning
    from pyanaconda import product

    from pyanaconda import isys
    isys.initLog()

    import signal, string

    from pyanaconda import iutil

    iutil.ipmi_report(constants.IPMI_STARTED)

    from pyanaconda import vnc
    from pyanaconda import kickstart
    from pyanaconda import ntp
    from pyanaconda import keyboard
    from pyanaconda.iutil import ProxyString, ProxyStringError

    verdesc = "%s for %s %s" % (getAnacondaVersionString(),
                                product.productName, product.productVersion)

    logs_note = " * installation log files are stored in /tmp during the installation"
    shell_and_tmux_note = " * shell is available on TTY2"
    shell_only_note = " * shell is available on TTY2 and in second TMUX pane (ctrl+b, then press 2)"
    tmux_only_note = " * shell is available in second TMUX pane (ctrl+b, then press 2)"
    text_mode_note = " * if the graphical installation interface fails to start, try again with the\n"\
                     "   inst.text bootoption to start text installation"
    separate_attachements_note = " * when reporting a bug add logs from /tmp as separate text/plain attachments"

    if product.isFinal:
        print "anaconda %s started." % verdesc
    else:
        print "anaconda %s (pre-release) started." % verdesc

    # we are past the --version and --help shortcut so we can import Blivet
    # now without slowing down anything critical

    # pylint: disable=import-error
    from blivet import arch

    if not opts.images and not opts.dirinstall:
        print(logs_note)
        # no fancy stuff like TTYs on a s390...
        if not arch.isS390():
            if "TMUX" in os.environ and os.environ.get("TERM") == "screen":
                print(shell_and_tmux_note)
            else:
                print(shell_only_note)  # TMUX is not running
        # ...but there is apparently TMUX during the manual installation on s390!
        elif not opts.ksfile:
            print(tmux_only_note)  # but not during kickstart installation
        # no need to tell users how to switch to text mode
        # if already in text mode
        if opts.display_mode == 'g':
            print(text_mode_note)
        print(separate_attachements_note)

    from pyanaconda.anaconda import Anaconda
    anaconda = Anaconda()
    iutil.setup_translations(gettext)

    # reset python's default SIGINT handler
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    signal.signal(signal.SIGSEGV, isys.handleSegv)
    signal.signal(signal.SIGTERM, lambda num, frame: sys.exit(1))

    setupEnvironment()
    # make sure we have /var/log soon, some programs fail to start without it
    iutil.mkdirChain("/var/log")

    pidfile = open("/var/run/anaconda.pid", "w")
    pidfile.write("%s\n" % (os.getpid(),))
    del pidfile

    anaconda.opts = opts

    # check memory, just the text mode for now:
    check_memory(anaconda, opts, 't')

    # Now that we've got arguments, do some extra processing.
    setupLoggingFromOpts(opts)

    # Default is to prompt to mount the installed system.
    anaconda.rescue_mount = not opts.rescue_nomount

    # assign the other anaconda variables from options
    anaconda.proxy = opts.proxy
    anaconda.updateSrc = opts.updateSrc
    anaconda.methodstr = opts.method
    anaconda.stage2 = opts.stage2
    flags.rescue_mode = opts.rescue


    if opts.liveinst:
        flags.livecdInstall = True

    # set flags
    flags.noverifyssl = opts.noverifyssl
    flags.armPlatform = opts.armPlatform
    flags.extlinux = opts.extlinux
    flags.mpathFriendlyNames = opts.mpathfriendlynames
    flags.debug = opts.debug
    flags.askmethod = opts.askmethod
    flags.dmraid = opts.dmraid
    flags.mpath = opts.mpath
    flags.ibft = opts.ibft
    flags.selinux = opts.selinux
    flags.eject = opts.eject

    if can_touch_runtime_system("start audit daemon"):
        startAuditDaemon()

    # setup links required for all install types
    for i in ( "services", "protocols", "nsswitch.conf", "joe", "selinux",
               "mke2fs.conf" ):
        try:
            if os.path.exists("/mnt/runtime/etc/" + i):
                os.symlink ("../mnt/runtime/etc/" + i, "/etc/" + i)
        except OSError:
            pass

    log.info("anaconda called with cmdline = %s", sys.argv)
    log.info("Default encoding = %s ", sys.getdefaultencoding())

    os.system("udevadm control --env=ANACONDA=1")

    # Collect all addon paths
    addon_paths = addons.collect_addon_paths(constants.ADDON_PATHS)

    # If we were given a kickstart file on the command line, parse (but do not
    # execute) that now.  Otherwise, load in defaults from kickstart files
    # shipped with the installation media.
    ksdata = None
    if opts.ksfile:
        flags.automatedInstall = True
        flags.eject = False
        files = [opts.ksfile]
    else:
        files = ["/tmp/updates/interactive-defaults.ks",
                 "/usr/share/anaconda/interactive-defaults.ks"]

    for ks in files:
        if not os.path.exists(ks):
            continue

        kickstart.preScriptPass(ks)
        log.info("Parsing kickstart: " + ks)
        ksdata = kickstart.parseKickstart(ks)

        # Only load the first defaults file we find.
        break

    if not ksdata:
        ksdata = kickstart.AnacondaKSHandler(addon_paths["ks"])

    # Pick up any changes from interactive-defaults.ks that would
    # otherwise be covered by the dracut KS parser.
    if ksdata.bootloader.extlinux:
        flags.extlinux = True
    if ksdata.rescue.rescue:
        flags.rescue_mode = True

    # Some kickstart commands must be executed immediately, as they affect
    # how anaconda operates.
    ksdata.logging.execute()

    anaconda.ksdata = ksdata

    # setup keyboard layout from the command line option and let
    # it override from kickstart if/when X is initialized
    if opts.keymap:
        if not ksdata.keyboard.keyboard:
            ksdata.keyboard.keyboard = opts.keymap

    if ksdata.keyboard.keyboard and can_touch_runtime_system("activate keyboard"):
        keyboard.activate_keyboard(ksdata.keyboard)

    # Some post-install parts of anaconda are implemented as kickstart
    # scripts.  Add those to the ksdata now.
    kickstart.appendPostScripts(ksdata)

    # cmdline flags override kickstart settings
    if anaconda.proxy:
        ksdata.method.proxy = anaconda.proxy

        # Setup proxy environmental variables so that pre/post scripts use it
        # as well as libreport
        try:
            proxy = ProxyString(anaconda.proxy)
        except ProxyStringError as e:
            log.info("Failed to parse proxy \"%s\": %s", anaconda.proxy, e)
        else:
            # Set environmental variables to be used by pre/post scripts
            os.environ["PROXY"] = proxy.noauth_url
            os.environ["PROXY_USER"] = proxy.username or ""
            os.environ["PROXY_PASSWORD"] = proxy.password or ""

            # Variables used by curl, libreport, etc.
            os.environ["http_proxy"] = proxy.url
            os.environ["ftp_proxy"] = proxy.url
            os.environ["HTTPS_PROXY"] = proxy.url

    if flags.noverifyssl:
        ksdata.method.noverifyssl = flags.noverifyssl
    if opts.multiLib:
        # sets yum's multilib_policy to "all" (as opposed to "best")
        ksdata.packages.multiLib = opts.multiLib

    # set ksdata.method based on anaconda.method if it isn't already set
    if anaconda.methodstr and not ksdata.method.seen:
        if anaconda.methodstr.startswith("cdrom"):
            ksdata.method.method = "cdrom"
        elif anaconda.methodstr.startswith("nfs"):
            ksdata.method.method = "nfs"
            (nfsOptions, server, path) = iutil.parseNfsUrl(anaconda.methodstr)
            ksdata.method.server = server
            ksdata.method.dir = path
            ksdata.method.opts = nfsOptions
        elif anaconda.methodstr.startswith("hd:"):
            ksdata.method.method = "harddrive"
            url = anaconda.methodstr.split(":", 1)[1]
            url_parts = url.split(":")
            device = url_parts[0]
            path = ""
            if len(url_parts) == 2:
                path = url_parts[1]
            elif len(url_parts) == 3:
                fstype = url_parts[1]   # XXX not used
                path = url_parts[2]

            ksdata.method.partition = device
            ksdata.method.dir = path
        elif anaconda.methodstr.startswith("http") or \
             anaconda.methodstr.startswith("ftp"):
            ksdata.method.method = "url"
            ksdata.method.url = anaconda.methodstr
        elif anaconda.methodstr.startswith("livecd"):
            ksdata.method.method = "harddrive"
            device = anaconda.methodstr.split(":", 1)[1]
            ksdata.method.partition = os.path.normpath(device)
        else:
            log.error("Unknown method: %s", (anaconda.methodstr,))

    # Override the selinux state from kickstart if set on the command line
    if flags.selinux != constants.SELINUX_DEFAULT:
        ksdata.selinux.selinux = flags.selinux

    from pyanaconda import localization
    # Set the language before loading an interface, when it may be too late.

    # check if the LANG environmental variable is set
    env_lang = os.environ.get("LANG")
    if env_lang is not None:
        # parse it using langtable
        env_langs = localization.get_language_locales(env_lang)
        # if parsed LANG is the same as our default language - ignore it;
        # otherwise use it as valid language candidate
        if env_langs and env_langs[0] != constants.DEFAULT_LANG:
            env_lang = env_langs[0]  # the first language is the best match
        else:
            env_lang = None

    requested_lang = opts.lang or ksdata.lang.lang or env_lang

    if requested_lang:
        locales = localization.get_language_locales(requested_lang)
        if locales:
            localization.setup_locale(locales[0], ksdata.lang)
            ksdata.lang.seen = True
        else:
            log.error("Invalid locale '%s' given on command line or in kickstart", requested_lang)
    else:
        # no kickstart or bootoption - use default
        localization.setup_locale(constants.DEFAULT_LANG, ksdata.lang)

    import blivet
    blivet.enable_installer_mode()

    # now start the interface
    setupDisplay(anaconda, opts, addon_paths)

    # we now know in which mode we are going to run so store the information
    from pykickstart.constants import DISPLAY_MODE_GRAPHICAL, DISPLAY_MODE_CMDLINE, DISPLAY_MODE_TEXT
    mode_char_to_const = {'g': DISPLAY_MODE_GRAPHICAL, 't': DISPLAY_MODE_TEXT, 'c': DISPLAY_MODE_CMDLINE}
    ksdata.displaymode.displayMode = mode_char_to_const[anaconda.displayMode]

    # if we're in text mode, the resulting system should be too
    # ...unless the kickstart specified otherwise
    if anaconda.displayMode != 'g' and not anaconda.ksdata.xconfig.startX:
        anaconda.ksdata.skipx.skipx = True

    if flags.rescue_mode:
        from pyanaconda import rescue
        anaconda.intf = rescue.RescueInterface()

    # Set flag to prompt for missing ks data
    if anaconda.displayMode == 'c':
        flags.ksprompt = False

    from pyanaconda.anaconda_argparse import name_path_pairs

    image_count = 0
    try:
        for (name, path) in name_path_pairs(opts.images):
            log.info("naming disk image '%s' '%s'", path, name)
            anaconda.storage.config.diskImages[name] = path
            image_count += 1
            flags.imageInstall = True
    except ValueError as e:
        stdoutLog.error("error specifying image file: %s", e)
        iutil.ipmi_report(constants.IPMI_ABORTED)
        sys.exit(0)

    if image_count:
        anaconda.storage.setupDiskImages()

    from pyanaconda import exception
    # comment out the next line to make exceptions non-fatal
    anaconda.mehConfig = exception.initExceptionHandling(anaconda)

    # add our own additional signal handlers
    signal.signal(signal.SIGUSR1, lambda signum, frame:
                                         exception.test_exception_handling())
    signal.signal(signal.SIGUSR2, lambda signum, frame: anaconda.dumpState())
    atexit.register(exitHandler, ksdata.reboot, anaconda.storage)

    from blivet import storageInitialize
    from pyanaconda.packaging import payloadMgr
    from pyanaconda.network import networkInitialize, wait_for_connecting_NM_thread
    from pyanaconda.timezone import time_initialize

    if flags.rescue_mode:
        rescue.doRescue(anaconda.intf, anaconda.rescue_mount, ksdata)
    else:
        cleanPStore()

    networkInitialize(ksdata)
    if not flags.dirInstall:
        threadMgr.add(AnacondaThread(name=constants.THREAD_STORAGE, target=storageInitialize,
                                     args=(anaconda.storage, ksdata, anaconda.protected)))
        threadMgr.add(AnacondaThread(name=constants.THREAD_TIME_INIT, target=time_initialize,
                                     args=(ksdata.timezone, anaconda.storage, anaconda.bootloader)))

    threadMgr.add(AnacondaThread(name=constants.THREAD_WAIT_FOR_CONNECTING_NM, target=wait_for_connecting_NM_thread, args=(ksdata,)))
    payloadMgr.restartThread(anaconda.storage, ksdata, anaconda.payload,
            fallback=not flags.automatedInstall)

    # check if geolocation should be enabled for this type of installation
    use_geolocation = True
    if flags.imageInstall or flags.dirInstall or flags.automatedInstall:
        use_geolocation = False
    # and also check if it was not disabled by boot option
    else:
        # flags.cmdline.getbool is used as it handles values such as
        # 0, no, off and also nogeoloc as False
        # and other values or geoloc not being present as True
        use_geolocation = flags.cmdline.getbool('geoloc', True)


    if use_geolocation:
        provider_id = constants.GEOLOC_DEFAULT_PROVIDER
        # check if a provider was specified by an option
        if opts.geoloc is not None:
            parsed_id = geoloc.get_provider_id_from_option(opts.geoloc)
            if parsed_id is None:
                log.error('geoloc: wrong provider id specified: %s',
                          opts.geoloc)
            else:
                provider_id = parsed_id
        # instantiate the geolocation module and start location data refresh
        geoloc.init_geolocation(provider_id=provider_id)
        geoloc.refresh()

    # setup ntp servers and start NTP daemon if not requested otherwise
    if can_touch_runtime_system("start chronyd"):
        if anaconda.ksdata.timezone.ntpservers:
            ntp.save_servers_to_config(anaconda.ksdata.timezone.ntpservers)

        if not anaconda.ksdata.timezone.nontp:
            iutil.start_service("chronyd")

    # try to load firmware language
    localization.load_firmware_language(ksdata.lang)

    # FIXME:  This will need to be made cleaner once this file starts to take
    # shape with the new UI code.
    anaconda._intf.setup(ksdata)
    anaconda._intf.run()

# vim:tw=78:ts=4:et:sw=4
